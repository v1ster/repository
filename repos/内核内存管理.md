---
title: 内核内存管理
date: 2023-04-14  
tags: linux kernal
---

## 记录

-  用 Kconfig 配 置 脚 本 和 Makefile 脚 本 编 写 的 更 详 细 信 息， 可 以 分 别 参 见 内 核 文 档Documentation 目录内的 kbuild 子目录下的 Kconfig-language.txt 和 Makefiles.txt 文件 

- Linux 有独特的编码风格，在内核源代码下存在一个文件 Documentation/CodingStyle，进行了比较详细的描述

- `(void) (&_x == &_y);` 判断 \_x 和 \_y 的类型是否一致, 这条语句的作用主要是为了产生一个编译器警告，以提示程序员可能存在的潜在问题。
```c
#def ine min(x,y) ({  \
const typeof(x) _x = (x); \
const typeof(y) _y = (y); \
(void) (&_x == &_y); \
_x < _y ? _x : _y; })
```

- GNU C 预定义了两个标识符保存当前函数的名字，\_ _FUNCTION_ \_ 保存函数在源码中的名字，\_\_PRETTY_FUNCTION\_\_ 保存带语言特色的名字。在 C 函数中，这两个名字是相同的。C99 已经支持 \_\_func\_\_ 宏，因此建议在 Linux 编程中不再使用 \_\_FUNCTION\_\_，而转而使用 \_\_func\_\_

- 在使用 gcc 编译 C 程序的时候，如果使用“-ansi –pedantic”编译选项，则会告诉编译器不使用 GNU 扩展语法。

- 访问共享资源的代码区域称为临界区(Critical Section),临界区需要被以某种互斥机制加以保护.==中断屏蔽\原子操作\自旋锁\信号量\互斥体等==是Linux设备驱动中可采用的互斥途径.

- 查看中断统计信息
```shell
cat /proc/interrupts
```

- 硬中断,软中断和信号的区别: 硬中断是外部设备对CPU的中断, 软中断是中断底半部的一种处理机制, 而信号则是由内核(或其他进程)对某个进程的中断. 

- 延迟有`忙等待`和`睡眠等待`,对延迟要求不是很精确的话使用睡眠等待,`ndelay(), udelay()` 忙等待通常为了配合硬件上的短时延迟

### 内存管理

```
											4GB +---------------------------+
												|  保留区	                |
												+---------------------------+
												|  专用页面映射区           |
								 /--------------+---------------------------+
								/    			|  高端内存映射区           |
	4GB		+----------------+-/    /-----------+---------------------------+
			|                |    /             +---------------------------+
			|                |   /              |  vmalloc 虚拟内存分配器区 |
	896MB	+----------------+==/               +---------------------------+
     		+----------------+  \---------------+---------------------------+
				物理内存       \                | 物理内存映射区             |
					            \---------------+---------------------------+
			                                            Linux 内核空间

							32位x86系统Linux 内核的地址空间
```


32位的x86,3~4GB 之间的内核空间中,从低地址到高地址依次为: 物理内存映射区->隔离带->vmalloc 虚拟内存分配去 -> 隔离带-> 高端内存映射区->专用页面映射区->保留区

- 物理内存映射区,低于16MB的区域为DMA区域,16~896MB之间为常规内存区域,高于896MB称为高端内存区域
	- 物理内存映射区可以用于访问硬件设备，例如显卡、网络接口卡等，因为这些设备通常被映射到物理内存地址空间中。通过将这些地址映射到进程的虚拟地址空间中，进程就可以直接访问硬件设备，而无需进行复杂的I/O操作。

- 虚拟内存分配区主要包括以下几个部分：
	1.  内核代码段（kernel text）：内核代码所在的虚拟地址空间，包括操作系统的核心代码和驱动程序等。
	2.  内核数据段（kernel data）：内核数据所在的虚拟地址空间，包括内核数据结构、全局变量等。
	3.  内核堆（kernel heap）：内核动态分配的内存空间，由kmalloc等函数管理。
	4.  内核栈（kernel stack）：内核函数调用时的局部变量和返回地址所在的空间。
	5.  内存映射区（mapped memory）：将文件映射到虚拟内存中，可以通过指针访问文件内容。
	6.  硬件映射区（hardware mappings）：将硬件设备的物理地址映射到内核虚拟地址空间中，以便内核可以直接访问硬件设备。

- 高端页面映射区
	- 超过物理内存映射区的物理内存通常被称为高端内存,在物理内存区域被称为常规内存

- 专用页面映射区

- 系统保留映射区


```
													虚拟地址
												+---------------------+
												|  向量表	          |
												+---------------------+
												+---------------------+
												|  vmalloc            |
												+---------------------+
									 /----------+---------------------+
				物理地址            /           |                     |
			+----------------+-\  /             |  DMA +常规内存区域  |
			|  高端内存      |   x              |    内存映射         |
			+----------------+=<  \             |                     |
	    	|  常规 +        |   \ /============+---------------------+
	    	|  DMA区域       |   /\             |  高端内存映射区     | 3GB
	    	+----------------+-/   \------------+---------------------+ 3GB-2MB
						                        | 内核模块            | 3GB-16MB
												+---------------------+ 
			                                    
							32位ARM 系统Linux 内核的地址空间
```


- devm 开头的函数,会在申请资源失败后自动调用 释放函数

- 需要注意 DMA 与 Cache 一致性
```C
/* 使 cache 无效 */
"mov    r0, #0\n"
"mcr    p15, 0, r0, c7, c7 0\n"       /* 使数据和指令cache 无效 */
"mcr    p15, 0, r0, c7, c10, 4\n"     /* 放空写缓存 */
"mcr    p15, 0, r0, c8, c7, 0\n"      /* 使 TLB 无效 */
```

## 随想

- 任务调度可以使用信号量实现, 死循环中等待信号量休眠
